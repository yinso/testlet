// Generated by CoffeeScript 1.4.0
(function() {
  var AsyncTest, NotRunner, Result, Runner, Test, deepEqual, forEach, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('./util'), deepEqual = _ref.deepEqual, forEach = _ref.forEach;

  Result = (function() {

    function Result(_case, expected, actual, textual) {
      var res;
      this["case"] = _case;
      this.expected = expected;
      this.actual = actual;
      this.textual = textual;
      this.pass = (function() {
        try {
          if (this.expected instanceof Function) {
            res = this.expected(this.actual);
            return res;
          } else {
            res = deepEqual(this.expected, this.actual);
            return res;
          }
        } catch (e) {
          this.error = e;
          return false;
        }
      }).call(this);
    }

    return Result;

  })();

  Test = (function() {

    Test.ok = function(val) {
      return val && !(val instanceof Error);
    };

    Test.throws = function(val) {
      return val instanceof Error;
    };

    Test.equals = function(rhs) {
      return function(lhs) {
        return deepEqual(lhs, rhs);
      };
    };

    Test.negate = function(expect) {
      if (expect instanceof Function) {
        return function(val) {
          return !expect(val);
        };
      } else {
        return function(val) {
          return !deepEqual(val, expect);
        };
      }
    };

    Test.isa = function(type) {
      if (typeof type === 'string') {
        return function(val) {
          return typeof val === type;
        };
      } else {
        return function(val) {
          return val instanceof type;
        };
      }
    };

    function Test(proc, expected, textual) {
      this.proc = proc;
      this.expected = expected;
      this.textual = textual;
      if (!(this.proc instanceof Function)) {
        proc = this.proc;
        this.proc = function() {
          return proc;
        };
      }
    }

    Test.prototype.run = function(next) {
      var result;
      result = (function() {
        try {
          return new Result(this, this.expected, this.proc(), this.textual);
        } catch (e) {
          return new Result(this, this.expected, e, this.textual);
        }
      }).call(this);
      return next(null, result);
    };

    return Test;

  })();

  AsyncTest = (function(_super) {

    __extends(AsyncTest, _super);

    function AsyncTest(proc, expected, textual) {
      this.proc = proc;
      this.expected = expected;
      this.textual = textual;
      if (!(this.proc instanceof Function)) {
        proc = this.proc;
        this.proc = function(cb) {
          return cb(null, proc);
        };
      }
    }

    AsyncTest.prototype.run = function(next) {
      var _this = this;
      return this.proc(function(err, res) {
        var result;
        result = err ? new Result(_this, _this.expected, err, _this.textual) : new Result(_this, _this.expected, res, _this.textual);
        return next(null, result);
      });
    };

    return AsyncTest;

  })(Test);

  NotRunner = (function() {

    NotRunner.prototype._not = function(expect) {};

    function NotRunner(prev) {
      this.prev = prev;
    }

    NotRunner.prototype.ok = function(proc, msg) {
      if (msg == null) {
        msg = proc.toString();
      }
      return this.prev.add(new Test(proc, Test.negate(Test.ok), {
        type: 'not.ok',
        msg: msg
      }));
    };

    NotRunner.prototype.okAsync = function(proc, msg) {
      if (msg == null) {
        msg = proc.toString();
      }
      return this.prev.add(new AsyncTest(proc, Test.negate(Test.ok), {
        type: 'not.ok',
        msg: msg
      }));
    };

    NotRunner.prototype.equal = function(lhs, rhs, msg) {
      if (msg == null) {
        msg = "" + lhs + " != " + rhs;
      }
      return this.prev.add(new Test(lhs, Test.negate(rhs), {
        type: 'not.equal',
        msg: msg
      }));
    };

    NotRunner.prototype.equalAsync = function(proc, rhs, msg) {
      if (msg == null) {
        msg = "" + (proc.toString()) + " != " + rhs;
      }
      return this.prev.add(new AsyncTest(proc, Test.negate(rhs), {
        type: 'not.equal',
        msg: msg
      }));
    };

    NotRunner.prototype["throw"] = function(proc, msg) {
      if (msg == null) {
        msg = proc.toString();
      }
      return this.prev.add(new Test(proc, Test.negate(Test.throws), {
        type: 'not.throw',
        msg: msg
      }));
    };

    NotRunner.prototype.throwAsync = function(proc, msg) {
      if (msg == null) {
        msg = proc.toString();
      }
      return this.prev.add(new AsyncTest(proc, Test.negate(Test.throws), {
        type: 'not.throw',
        msg: msg
      }));
    };

    NotRunner.prototype.isa = function(lhs, type, msg) {
      if (msg == null) {
        msg = "" + lhs + " is-not-a " + type;
      }
      return this.prev.add(new Test(lhs, Test.negate(Test.isa(type)), {
        type: 'not.isa',
        msg: msg
      }));
    };

    NotRunner.prototype.isaAsync = function(lhs, type, msg) {
      if (msg == null) {
        msg = "" + lhs + " is-not-a " + type;
      }
      return this.prev.add(new AsyncTest(lhs, Test.negate(Test.isa(type)), {
        type: 'not.isa',
        msg: msg
      }));
    };

    return NotRunner;

  })();

  Runner = (function() {

    function Runner() {
      this.cases = [];
      this['not'] = new NotRunner(this);
    }

    Runner.prototype.add = function(test) {
      return this.cases.push(test);
    };

    Runner.prototype.ok = function(proc, msg) {
      if (msg == null) {
        msg = proc.toString();
      }
      return this.cases.push(new Test(proc, Test.ok, {
        type: 'ok',
        msg: msg
      }));
    };

    Runner.prototype.okAsync = function(proc, msg) {
      if (msg == null) {
        msg = proc.toString();
      }
      return this.cases.push(new AsyncTest(proc, Test.ok, {
        type: 'ok',
        msg: msg
      }));
    };

    Runner.prototype.equal = function(lhs, rhs, msg) {
      if (msg == null) {
        msg = "" + lhs + " == " + rhs;
      }
      return this.cases.push(new Test(lhs, rhs, {
        type: 'equal',
        msg: msg
      }));
    };

    Runner.prototype.equalAsync = function(proc, rhs, msg) {
      if (msg == null) {
        msg = "" + (proc.toString()) + " == " + rhs;
      }
      return this.cases.push(new AsyncTest(proc, rhs, {
        type: 'equal',
        msg: msg
      }));
    };

    Runner.prototype["throw"] = function(proc, msg) {
      if (msg == null) {
        msg = proc.toString();
      }
      return this.cases.push(new Test(proc, Test.throws, {
        type: 'throw',
        msg: msg
      }));
    };

    Runner.prototype.throwAsync = function(proc, msg) {
      if (msg == null) {
        msg = proc.toString();
      }
      return this.cases.push(new AsyncTest(proc, Test.throws, {
        type: 'throw',
        msg: msg
      }));
    };

    Runner.prototype.isa = function(lhs, type, msg) {
      if (msg == null) {
        msg = "" + lhs + " is-a " + type;
      }
      return this.cases.push(new Test(lhs, Test.isa(type), {
        type: 'isa',
        msg: msg
      }));
    };

    Runner.prototype.isaAsync = function(lhs, type, msg) {
      if (msg == null) {
        msg = "" + lhs + " is-a " + type;
      }
      return this.cases.push(new AsyncTest(lhs, Test.isa(type), {
        type: 'isa',
        msg: msg
      }));
    };

    Runner.prototype.run = function(cb) {
      var cases, helper, results;
      results = [];
      cases = [].concat(this.cases);
      helper = function(test, next) {
        return test.run(function(err, res) {
          if (err) {
            return next(err);
          } else {
            results.push(res);
            return next(null, results);
          }
        });
      };
      return forEach(cases, helper, function(err, res) {
        return cb(err, results);
      });
    };

    return Runner;

  })();

  module.exports = Runner;

}).call(this);
